<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vending Machine Frame</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="info">
        <strong>Vending Machine Internal Frame</strong><br>
        Dimensions: 24"W × 60"H × 24"D<br>
        Grid: 3 across × 5 down = 15 slots<br>
        Slot size: 8"W × 10"H × 18"D<br>
        Collection area: 10"H (bottom)
    </div>
    <div id="controls">
        Scroll to rotate | Shift+Scroll to zoom | Drag to rotate
    </div>
    <div id="menu">
        <div id="menu-header">
            <span>Menu</span>
            <span id="menu-toggle">☰</span>
        </div>
        <div id="menu-content">
            <div class="menu-item">
                <input type="checkbox" id="toggle-cutlist" class="hidden-checkbox">
                <label for="toggle-cutlist" class="button-label">Cut List View</label>
            </div>
            <div style="border-top: 1px solid rgba(255,255,255,0.2); margin: 10px 0;"></div>
            <div class="menu-item">
                <input type="checkbox" id="toggle-external" class="hidden-checkbox" checked>
                <label for="toggle-external" class="button-label">External Frame</label>
            </div>
            <div class="menu-item">
                <input type="checkbox" id="toggle-shelves" class="hidden-checkbox" checked>
                <label for="toggle-shelves" class="button-label">Shelves</label>
            </div>
            <div class="menu-item">
                <input type="checkbox" id="toggle-rails" class="hidden-checkbox" checked>
                <label for="toggle-rails" class="button-label">Rails</label>
            </div>
            <div class="menu-item">
                <input type="checkbox" id="toggle-dividers" class="hidden-checkbox" checked>
                <label for="toggle-dividers" class="button-label">Dividers</label>
            </div>
            <div class="menu-item">
                <input type="checkbox" id="toggle-glass" class="hidden-checkbox" checked>
                <label for="toggle-glass" class="button-label">Glass Front</label>
            </div>
            <div class="menu-item">
                <input type="checkbox" id="toggle-motors" class="hidden-checkbox" checked>
                <label for="toggle-motors" class="button-label">Motors</label>
            </div>
            <div class="menu-item">
                <input type="checkbox" id="toggle-clamps" class="hidden-checkbox" checked>
                <label for="toggle-clamps" class="button-label">Clamps</label>
            </div>
            <div class="menu-item">
                <input type="checkbox" id="toggle-spirals" class="hidden-checkbox" checked>
                <label for="toggle-spirals" class="button-label">Spirals</label>
            </div>
            <div style="border-top: 1px solid rgba(255,255,255,0.2); margin: 10px 0;"></div>
            <div class="menu-item">
                <input type="checkbox" id="toggle-pause" class="hidden-checkbox">
                <label for="toggle-pause" class="button-label">Pause & Front View</label>
            </div>
            <div id="dimensions-display" style="padding: 10px 0; border-top: 1px solid rgba(255,255,255,0.2); margin-top: 10px;">
                <!-- Dimensions will be generated dynamically by JavaScript -->
            </div>
        </div>
    </div>
    <div id="parts-overlay">
        <!-- Cut list will be generated dynamically by JavaScript -->
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configuration - all dimensions and parameters in one place
        const CONFIG = {
            frame: {
                width: 24,
                height: 60,
                depth: 24,
                thickness: 0.33
            },
            grid: {
                rows: 5,
                cols: 3
            },
            slot: {
                width: 8,
                height: 10,
                depth: 18
            },
            collection: {
                height: 10,
                slantAngle: 0.3
            },
            shelves: {
                depth: 18  // Shallower than frame depth to create collection area
            },
            rails: {
                width: 1,
                height: 0.5,
                gap: 1,  // Distance below shelf
                inset: 2  // Distance from edge
            },
            dividers: {
                height: 5  // Half the slot height
            },
            glass: {
                thickness: 0.2,
                offset: 2  // Distance in front of shelves
            },
            motor: {
                radius: 1,
                length: 2.5
            },
            bracket: {
                width: 2,
                height: 2,
                thickness: 0.2
            },
            spiral: {
                radius: 3,
                length: 14,
                turns: 8,
                tubeRadius: 0.15
            }
        };

        let scene, camera, renderer;
        let frameGroup, externalFrame, internalFrame, glassFront, motorsGroup, clampsGroup, spiralsGroup;
        let shelvesGroup, railsGroup, dividersGroup;
        let mouseDown = false, mouseX = 0, mouseY = 0;
        let isPartsView = false;
        let isPaused = false;
        let defaultCameraPos = { x: 50, y: 40, z: 70 };

        // Create all materials
        function createMaterials() {
            const textureLoader = new THREE.TextureLoader();

            // Load textures
            const plywoodTexture = textureLoader.load('plywood.jpg');
            plywoodTexture.wrapS = THREE.RepeatWrapping;
            plywoodTexture.wrapT = THREE.RepeatWrapping;

            const plywoodSideTexture = textureLoader.load('plywood-side.jpg');
            plywoodSideTexture.wrapS = THREE.RepeatWrapping;
            plywoodSideTexture.wrapT = THREE.RepeatWrapping;

            return {
                plywood: new THREE.MeshPhongMaterial({
                    map: plywoodTexture,
                    side: THREE.DoubleSide
                }),
                plywoodSide: new THREE.MeshPhongMaterial({
                    map: plywoodSideTexture,
                    side: THREE.DoubleSide
                }),
                edge: new THREE.MeshPhongMaterial({
                    color: 0x8b6f47
                }),
                glass: new THREE.MeshPhongMaterial({
                    color: 0x88ccff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide,
                    shininess: 100
                }),
                rail: new THREE.MeshPhongMaterial({
                    color: 0x777777,
                    shininess: 40,
                    metalness: 0.6
                }),
                motor: new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    shininess: 30
                }),
                bracket: new THREE.MeshPhongMaterial({
                    color: 0x666666,
                    shininess: 20
                }),
                spiral: new THREE.MeshPhongMaterial({
                    color: 0xaaaaaa,
                    shininess: 80,
                    metalness: 0.8
                })
            };
        }

        // Positioning helper functions
        function getShelfY(rowIndex) {
            return -CONFIG.frame.height/2 + (rowIndex * CONFIG.slot.height);
        }

        function getBackZ() {
            return -(CONFIG.frame.depth - CONFIG.shelves.depth) / 2;
        }

        function getSlotCenter(row, col) {
            const x = -CONFIG.frame.width/2 + (col * CONFIG.slot.width) + (CONFIG.slot.width / 2);
            const y = -CONFIG.frame.height/2 + (row * CONFIG.slot.height) + (CONFIG.slot.height / 2);
            const z = getBackZ() - CONFIG.shelves.depth / 2;
            return { x, y, z };
        }

        function getSlotPosition(row, col) {
            return getSlotCenter(row, col);
        }

        // Component factory functions
        function createExternalFrame(materials) {
            const group = new THREE.Group();
            const { width, height, depth, thickness } = CONFIG.frame;

            // Back panel
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, thickness),
                materials.plywoodSide
            );
            back.position.z = -depth/2;
            group.add(back);

            // Side panels
            const leftSide = new THREE.Mesh(
                new THREE.BoxGeometry(thickness, height, depth),
                materials.plywood
            );
            leftSide.position.x = -width/2;
            group.add(leftSide);

            const rightSide = new THREE.Mesh(
                new THREE.BoxGeometry(thickness, height, depth),
                materials.plywood
            );
            rightSide.position.x = width/2;
            group.add(rightSide);

            // Top and bottom
            const top = new THREE.Mesh(
                new THREE.BoxGeometry(width, thickness, depth),
                materials.plywood
            );
            top.position.y = height/2;
            group.add(top);

            const bottom = new THREE.Mesh(
                new THREE.BoxGeometry(width, thickness, depth),
                materials.plywood
            );
            bottom.position.y = -height/2;
            group.add(bottom);

            // Wireframe edges
            const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(width, height, depth));
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
            group.add(line);

            return group;
        }

        function createShelf(rowIndex, materials) {
            const shelf = new THREE.Mesh(
                new THREE.BoxGeometry(CONFIG.frame.width, CONFIG.frame.thickness, CONFIG.shelves.depth),
                materials.plywood
            );
            shelf.position.y = getShelfY(rowIndex);
            shelf.position.z = getBackZ();
            return shelf;
        }

        function createRails(rowIndex, materials) {
            const group = new THREE.Group();
            const y = getShelfY(rowIndex) - CONFIG.rails.gap;
            const z = getBackZ();

            // Left rail
            const leftRail = new THREE.Mesh(
                new THREE.BoxGeometry(CONFIG.rails.width, CONFIG.rails.height, CONFIG.shelves.depth),
                materials.rail
            );
            leftRail.position.set(-CONFIG.frame.width/2 + CONFIG.rails.inset, y, z);
            group.add(leftRail);

            // Right rail
            const rightRail = new THREE.Mesh(
                new THREE.BoxGeometry(CONFIG.rails.width, CONFIG.rails.height, CONFIG.shelves.depth),
                materials.rail
            );
            rightRail.position.set(CONFIG.frame.width/2 - CONFIG.rails.inset, y, z);
            group.add(rightRail);

            return group;
        }

        function createDividers(rowIndex, materials) {
            const group = new THREE.Group();
            const y = getShelfY(rowIndex) + CONFIG.dividers.height/2;
            const z = getBackZ();

            // Create dividers based on grid columns
            for (let col = 1; col < CONFIG.grid.cols; col++) {
                const divider = new THREE.Mesh(
                    new THREE.BoxGeometry(CONFIG.frame.thickness, CONFIG.dividers.height, CONFIG.shelves.depth),
                    materials.plywood
                );
                divider.position.set(-CONFIG.frame.width/2 + (col * CONFIG.slot.width), y, z);
                group.add(divider);
            }

            return group;
        }

        function createCollectionBin(materials) {
            const binFloor = new THREE.Mesh(
                new THREE.BoxGeometry(CONFIG.frame.width, CONFIG.frame.thickness, CONFIG.frame.depth - 6),
                materials.plywood
            );
            binFloor.position.set(0, -CONFIG.frame.height/2 + 3, 3);
            binFloor.rotation.x = CONFIG.collection.slantAngle;
            return binFloor;
        }

        function createGlassFront(materials) {
            const glassHeight = CONFIG.grid.rows * CONFIG.slot.height;
            const glass = new THREE.Mesh(
                new THREE.BoxGeometry(CONFIG.frame.width, glassHeight, CONFIG.glass.thickness),
                materials.glass
            );
            glass.position.set(0, CONFIG.slot.height/2, CONFIG.shelves.depth/2 + CONFIG.glass.offset);
            return glass;
        }

        function createMotorAssembly(row, col, materials) {
            const assembly = { motor: null, bracket: null, spiral: null };
            const pos = getSlotCenter(row, col);
            const zBack = pos.z;

            // Motor (cylinder at back)
            const motor = new THREE.Mesh(
                new THREE.CylinderGeometry(CONFIG.motor.radius, CONFIG.motor.radius, CONFIG.motor.length, 16),
                materials.motor
            );
            motor.rotation.z = Math.PI / 2; // Rotate to horizontal
            motor.position.set(pos.x, pos.y, zBack + 1);
            assembly.motor = motor;

            // Mounting bracket (flat box behind motor)
            const bracket = new THREE.Mesh(
                new THREE.BoxGeometry(CONFIG.bracket.width, CONFIG.bracket.height, CONFIG.bracket.thickness),
                materials.bracket
            );
            bracket.position.set(pos.x, pos.y, zBack - 0.5);
            assembly.bracket = bracket;

            // Spiral coil (helix from motor to front)
            const points = [];
            for (let i = 0; i <= 100; i++) {
                const t = i / 100;
                const angle = t * CONFIG.spiral.turns * Math.PI * 2;
                const x = Math.cos(angle) * CONFIG.spiral.radius;
                const y = Math.sin(angle) * CONFIG.spiral.radius;
                const z = t * CONFIG.spiral.length;
                points.push(new THREE.Vector3(x, y, z));
            }
            const curve = new THREE.CatmullRomCurve3(points);
            const spiral = new THREE.Mesh(
                new THREE.TubeGeometry(curve, 200, CONFIG.spiral.tubeRadius, 8, false),
                materials.spiral
            );
            spiral.position.set(pos.x, pos.y, zBack + 2);
            assembly.spiral = spiral;

            return assembly;
        }

        // Generate dimensions display dynamically from CONFIG
        function generateDimensionsDisplay() {
            const { width, height, depth } = CONFIG.frame;
            const widthCm = (width * 2.54).toFixed(0);
            const heightCm = (height * 2.54).toFixed(0);
            const depthCm = (depth * 2.54).toFixed(0);
            const widthFt = (width / 12).toFixed(0);
            const heightFt = (height / 12).toFixed(0);
            const depthFt = (depth / 12).toFixed(0);
            const widthM = (width * 0.0254).toFixed(2);
            const heightM = (height * 0.0254).toFixed(2);
            const depthM = (depth * 0.0254).toFixed(2);

            return `
                <div style="font-weight: bold; margin-bottom: 8px; font-size: 13px;">Dimensions</div>
                <div class="dimension-row">
                    <span class="dimension-label">Width:</span>
                    <span class="dimension-value">${width}" / ${widthCm}cm / ${widthFt}ft / ${widthM}m</span>
                </div>
                <div class="dimension-row">
                    <span class="dimension-label">Height:</span>
                    <span class="dimension-value">${height}" / ${heightCm}cm / ${heightFt}ft / ${heightM}m</span>
                </div>
                <div class="dimension-row">
                    <span class="dimension-label">Depth:</span>
                    <span class="dimension-value">${depth}" / ${depthCm}cm / ${depthFt}ft / ${depthM}m</span>
                </div>
            `;
        }

        // Generate cut list dynamically from CONFIG
        function generateCutList() {
            const { width, height, depth } = CONFIG.frame;
            const widthFt = (width / 12).toFixed(0);
            const heightFt = (height / 12).toFixed(0);
            const depthFt = (depth / 12).toFixed(0);

            return `
                <div class="parts-layout">
                    <div class="parts-row">
                        <div class="panel panel-2x2">
                            <div class="panel-label">Top</div>
                            <div class="dim-label dim-width">${widthFt}ft</div>
                            <div class="dim-label dim-height">${depthFt}ft</div>
                        </div>
                        <div class="panel panel-2x2">
                            <div class="panel-label">Bottom</div>
                            <div class="dim-label dim-width">${widthFt}ft</div>
                            <div class="dim-label dim-height">${depthFt}ft</div>
                        </div>
                    </div>
                    <div class="parts-row">
                        <div class="panel panel-2x5">
                            <div class="panel-label">Back</div>
                            <div class="dim-label dim-width">${widthFt}ft</div>
                            <div class="dim-label dim-height">${heightFt}ft</div>
                        </div>
                        <div class="panel panel-2x5">
                            <div class="panel-label">Side</div>
                            <div class="dim-label dim-width">${depthFt}ft</div>
                            <div class="dim-label dim-height">${heightFt}ft</div>
                        </div>
                        <div class="panel panel-2x5">
                            <div class="panel-label">Side</div>
                            <div class="dim-label dim-width">${depthFt}ft</div>
                            <div class="dim-label dim-height">${heightFt}ft</div>
                        </div>
                    </div>
                    <div class="parts-row">
                        <div class="panel-label" style="margin: 20px 0; font-weight: bold;">
                            Shelves: ${CONFIG.grid.rows} @ ${widthFt}ft × ${(CONFIG.shelves.depth / 12).toFixed(1)}ft
                        </div>
                    </div>
                    <div class="parts-row">
                        <div class="panel-label" style="margin: 20px 0; font-weight: bold;">
                            Dividers: ${CONFIG.grid.rows * (CONFIG.grid.cols - 1)} @ ${(CONFIG.dividers.height / 12).toFixed(1)}ft × ${(CONFIG.shelves.depth / 12).toFixed(1)}ft
                        </div>
                    </div>
                </div>
            `;
        }

        function init() {
            // Generate and populate cut list
            const partsOverlay = document.getElementById('parts-overlay');
            partsOverlay.innerHTML = generateCutList();

            // Generate and populate dimensions display
            const dimensionsDisplay = document.getElementById('dimensions-display');
            dimensionsDisplay.innerHTML = generateDimensionsDisplay();

            // Update info display with CONFIG values
            const info = document.getElementById('info');
            info.innerHTML = `
                <strong>Vending Machine Internal Frame</strong><br>
                Dimensions: ${CONFIG.frame.width}"W × ${CONFIG.frame.height}"H × ${CONFIG.frame.depth}"D<br>
                Grid: ${CONFIG.grid.cols} across × ${CONFIG.grid.rows} down = ${CONFIG.grid.cols * CONFIG.grid.rows} slots<br>
                Slot size: ${CONFIG.slot.width}"W × ${CONFIG.slot.height}"H × ${CONFIG.slot.depth}"D<br>
                Collection area: ${CONFIG.collection.height}"H (bottom)
            `;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 40, 70);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            // Frame group
            frameGroup = new THREE.Group();
            scene.add(frameGroup);

            // External frame group (outer box)
            externalFrame = new THREE.Group();
            frameGroup.add(externalFrame);

            // Internal frame group (shelves and dividers)
            internalFrame = new THREE.Group();
            frameGroup.add(internalFrame);

            // Rack system groups (separate for shelves, rails, dividers)
            shelvesGroup = new THREE.Group();
            frameGroup.add(shelvesGroup);

            railsGroup = new THREE.Group();
            frameGroup.add(railsGroup);

            dividersGroup = new THREE.Group();
            frameGroup.add(dividersGroup);

            // Dispensing mechanism groups (separate for motors, clamps, spirals)
            motorsGroup = new THREE.Group();
            frameGroup.add(motorsGroup);

            clampsGroup = new THREE.Group();
            frameGroup.add(clampsGroup);

            spiralsGroup = new THREE.Group();
            frameGroup.add(spiralsGroup);

            // Create materials
            const materials = createMaterials();

            // Create external frame
            const frameGeometry = createExternalFrame(materials);
            externalFrame.add(...frameGeometry.children);

            // Create glass front
            glassFront = createGlassFront(materials);
            frameGroup.add(glassFront);

            // Create collection bin
            const binFloor = createCollectionBin(materials);
            internalFrame.add(binFloor);

            // Create shelves for each row
            for (let i = 1; i <= CONFIG.grid.rows; i++) {
                shelvesGroup.add(createShelf(i, materials));
            }

            // Create rails for each row
            for (let i = 1; i <= CONFIG.grid.rows; i++) {
                const rails = createRails(i, materials);
                railsGroup.add(...rails.children);
            }

            // Create dividers for each row
            for (let i = 1; i <= CONFIG.grid.rows; i++) {
                const dividers = createDividers(i, materials);
                dividersGroup.add(...dividers.children);
            }

            // Create dispensing mechanisms for all slots
            for (let row = 1; row <= CONFIG.grid.rows; row++) {
                for (let col = 0; col < CONFIG.grid.cols; col++) {
                    const assembly = createMotorAssembly(row, col, materials);
                    motorsGroup.add(assembly.motor);
                    clampsGroup.add(assembly.bracket);
                    spiralsGroup.add(assembly.spiral);
                }
            }

            // Mouse controls
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);

            window.addEventListener('resize', onWindowResize);

            // Menu controls - dynamic setup
            const menuHeader = document.getElementById('menu-header');
            const menu = document.getElementById('menu');
            const toggleCutlist = document.getElementById('toggle-cutlist');
            const togglePause = document.getElementById('toggle-pause');

            // Menu toggle configuration - maps toggle IDs to their target groups
            const menuToggles = [
                { id: 'toggle-external', target: () => externalFrame },
                { id: 'toggle-shelves', target: () => shelvesGroup },
                { id: 'toggle-rails', target: () => railsGroup },
                { id: 'toggle-dividers', target: () => dividersGroup },
                { id: 'toggle-glass', target: () => glassFront },
                { id: 'toggle-motors', target: () => motorsGroup },
                { id: 'toggle-clamps', target: () => clampsGroup },
                { id: 'toggle-spirals', target: () => spiralsGroup }
            ];

            menuHeader.addEventListener('click', () => {
                menu.classList.toggle('collapsed');
            });

            toggleCutlist.addEventListener('change', (e) => {
                if (e.target.checked) {
                    // Switch to parts view
                    isPartsView = true;
                    renderer.domElement.style.display = 'none';
                    partsOverlay.classList.add('active');
                    document.body.style.background = '#d4a574';

                    // Uncheck and hide frame toggles
                    menuToggles.forEach(toggle => {
                        const element = document.getElementById(toggle.id);
                        element.checked = false;
                        toggle.target().visible = false;
                    });
                } else {
                    // Return to 3D view
                    isPartsView = false;
                    renderer.domElement.style.display = 'block';
                    partsOverlay.classList.remove('active');
                    document.body.style.background = '';

                    // Re-enable and check frame toggles
                    menuToggles.forEach(toggle => {
                        const element = document.getElementById(toggle.id);
                        element.checked = true;
                        toggle.target().visible = true;
                    });
                }
            });

            // Setup visibility toggles dynamically
            menuToggles.forEach(toggle => {
                const element = document.getElementById(toggle.id);
                element.addEventListener('change', (e) => {
                    toggle.target().visible = e.target.checked;
                });
                // Initialize visibility based on checkbox state
                toggle.target().visible = element.checked;
            });

            togglePause.addEventListener('change', (e) => {
                isPaused = e.target.checked;
                if (isPaused) {
                    frameGroup.rotation.set(0, Math.PI * 0.25, 0);
                }
            });

            animate();
        }

        function onMouseDown(e) {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        function onMouseMove(e) {
            if (!mouseDown || isPartsView) return;

            const deltaX = e.clientX - mouseX;
            const deltaY = e.clientY - mouseY;

            frameGroup.rotation.y += deltaX * 0.01;
            frameGroup.rotation.x += deltaY * 0.01;

            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        function onMouseUp() {
            mouseDown = false;
        }

        function onWheel(e) {
            e.preventDefault();

            // If shift is held, zoom in/out
            if (e.shiftKey) {
                camera.position.z += e.deltaY * 0.05;
                camera.position.z = Math.max(30, Math.min(150, camera.position.z));
            } else {
                // Otherwise, use scroll to rotate
                // deltaX = horizontal scroll (rotates around Y axis)
                // deltaY = vertical scroll (rotates around X axis)
                frameGroup.rotation.y += e.deltaX * 0.005;
                frameGroup.rotation.x += e.deltaY * 0.005;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!isPartsView && !isPaused) {
                frameGroup.rotation.y += 0.002; // Slow auto-rotation
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
